# Applier Tool Guide

Complete guide to using the CyberPatchMaker applier tool for applying delta patches to installations.

## Overview

The applier tool safely applies binary patches to existing installations. It verifies the current version, creates selective backups of files being changed, applies modifications, and validates the result.

## Basic Usage

### Apply Patch with Full Verification

**The recommended method** - apply patch with complete safety checks:

```bash
patch-apply --patch ./patches/1.0.0-to-1.0.3.patch --current-dir ./myapp --verify
```

This will:
1. Load and display patch information
2. Verify current version is 1.0.0 (pre-verification)
3. Create selective backup of files being modified/deleted
4. Apply all patch operations
5. Verify result matches version 1.0.3 (post-verification)
6. Preserve backup for manual rollback (or restore on failure)

**Example Output:**
```
Loading patch: patches/1.0.0-to-1.0.3.patch

=== Patch Information ===
From Version: 1.0.0
To Version:   1.0.3
Key File:     program.exe
Created:      2025-10-04 10:30:00
Patch Size:   2.1 MB
Compression:  zstd

Operations:
  5 files to add
  12 files to modify
  3 files to delete
  2 directories to add

Applying patch from 1.0.0 to 1.0.3...
Verifying current version...
Pre-patch verification successful

Creating selective backup...
Backing up: program.exe
Backing up: data\config.json
Backing up: libs\oldfeature.dll
Backup created in: C:\MyApp\backup.cyberpatcher

Applying 20 operations...
  Modified: program.exe
  Modified: data/config.json
  Added: libs/newfeature.dll
  Deleted: libs/oldfeature.dll
  ... (16 more operations)

Post-patch verification successful

=== Patch Applied Successfully ===
Version updated from 1.0.0 to 1.0.3
Backup preserved in: C:\MyApp\backup.cyberpatcher
Time elapsed: 12.3 seconds
```

---

### Dry-Run Mode (Preview Changes)

**Preview what would happen** without making any changes:

```bash
patch-apply --patch ./patches/1.0.0-to-1.0.3.patch --current-dir ./myapp --dry-run
```

This will:
1. Load patch information
2. Display what operations would be performed
3. **NOT** create backup
4. **NOT** apply any changes
5. **NOT** modify any files

**Example Output:**
```
Loading patch: patches/1.0.0-to-1.0.3.patch

=== Patch Information ===
From Version: 1.0.0
To Version:   1.0.3
Key File:     program.exe

=== DRY RUN MODE - NO CHANGES WILL BE MADE ===

Would perform the following operations:
  ADD:    libs/newfeature.dll (2.1 MB)
  MODIFY: program.exe (52.4 MB)
  MODIFY: data/config.json (1.2 KB)
  DELETE: libs/oldfeature.dll
  ... (16 more operations)

Total size of changes: 54.7 MB

Dry-run completed successfully
No changes were made to your installation
```

---

## Command-Line Options

### Required Options

**`--patch <path>`**
- Path to the patch file
- Must be a .patch file generated by the generator tool
- Example: `./patches/1.0.0-to-1.0.3.patch`

**`--current-dir <path>`**
- Directory containing the current installation
- Must contain the expected source version
- Example: `C:\MyApp\`

### Optional Options

**`--key-file <path>`**
- Specify custom key file path if renamed or moved
- Can be absolute path or relative to current-dir
- Example: `--key-file app.exe` or `--key-file C:\MyApp\renamed.exe`
- Use case: When the key file (typically the main executable) has been renamed
- Default: Uses key file path stored in patch

**`--verify`** (Enabled by Default)
- Check files before and after patching
- Verifies current version before patching
- Verifies result after patching
- Default: `true` (enabled)
- Disable with `--verify=false` (not recommended)

**`--backup`** (Enabled by Default)
- Create backup of changed files before patching
- Selective backup (only files being modified/deleted)
- Backup saved to `{current-dir}.backup.cyberpatcher`
- Default: `true` (enabled)
- Disable with `--backup=false` (not recommended)
- Manual rollback: Delete patched files, restore from backup

**`--dry-run`**
- Preview mode - show what would happen
- No backup created
- No changes made
- Useful for testing and planning

**`--help`**
- Display usage information
- Shows all available options

---

## Safety Features

### Pre-Verification

Before any changes are made, the applier verifies:

1. **Key File Verification**
   - Checks that the key file (e.g., program.exe) exists
   - Calculates SHA-256 hash of the key file
   - Compares against required hash from patch
   - **Fails if hash doesn't match** → Wrong version or corrupted

2. **Required Files Verification**
   - Checks that all required files exist
   - Calculates SHA-256 hash of each required file
   - Compares against required hashes from patch
   - **Fails if any hash doesn't match** → Modified or corrupted installation

**If Pre-Verification Fails:**
- **NO BACKUP is created** (why backup corrupted state?)
- **NO CHANGES are made** (patch rejected immediately)
- Error message explains what's wrong
- Installation remains in current state (unmodified)

---

### Backup Creation

**When:** After pre-verification passes, before any operations

**Location:** **INSIDE** target directory at `<current-dir>\backup.cyberpatcher\`
- Example: If current-dir is `C:\MyApp\`, backup is `C:\MyApp\backup.cyberpatcher\`

**Contents:** **Selective** mirror-structure backup of only files being changed
- **Modified files** (OpModify operations): Backed up before changes
- **Deleted files** (OpDelete operations): Backed up before deletion
- **NOT backed up**: New files being added (OpAdd) - they don't exist yet
- **Directory structure**: Mirrored exactly to preserve original paths
- **File permissions**: Preserved where supported

**Cleanup:**
- **On success**: Backup is **PRESERVED** (kept for manual rollback if needed)
- **On failure**: Backup **PRESERVED** (used for automatic rollback, then kept for investigation)
- **User action**: Delete `backup.cyberpatcher` folder when no longer needed

---

### Post-Verification

After all operations are applied, the applier verifies:

1. **Modified Files Verification**
   - Calculates SHA-256 hash of every modified/added file
   - Compares against expected hashes from patch
   - **Fails if any hash doesn't match** → Operation failed or corrupted

2. **Target Key File Verification**
   - Verifies key file now has target version hash
   - Ensures version was successfully updated

**If Post-Verification Fails:**
- **Backup is restored** (return to clean state)
- Error message explains what went wrong
- Installation returns to original state
- User can investigate and retry

---

## Understanding Errors

### Pre-Verification Errors

**"Key file checksum mismatch"**
```
Error: patch application failed: key file verification failed: 
  key file checksum mismatch: 
  expected 63573ff071ea5fa2...
  got      8f3c9d2e1a4b7c5e...
```

**Meaning:** Your key file (program.exe) doesn't match expected version

**Causes:**
- Applying wrong patch (e.g., 1.0.0→1.0.3 patch to version 1.0.1)
- Key file was modified or corrupted
- Different application entirely

**Solution:**
- Verify you have the correct version installed
- Use patch matching your current version
- Re-install clean version if corrupted

---

**"Required file missing or modified"**
```
Error: patch application failed: required file verification failed: 
  file "data/config.json" checksum mismatch:
  expected a1b2c3d4e5f6...
  got      z9y8x7w6v5u4...
```

**Meaning:** A file in your installation was modified or corrupted

**Causes:**
- User edited files manually
- File corruption
- Incomplete installation
- Previous patch failed

**Solution:**
- Re-install clean source version
- Don't manually edit application files
- Check disk for errors

---

### Operation Errors

**"Permission denied"**
```
Error: failed to write file: permission denied
Restoring from backup...
```

**Meaning:** Cannot write to files (insufficient permissions)

**Causes:**
- Files are in use (application running)
- Insufficient user permissions
- Read-only files
- Antivirus blocking

**Solution:**
- Close the application before patching
- Run applier as administrator
- Check file permissions
- Temporarily disable antivirus

---

**"Disk full"**
```
Error: failed to write file: no space left on device
Restoring from backup...
```

**Meaning:** Not enough disk space

**Causes:**
- Disk is full
- Backup requires additional space
- Large patch operations

**Solution:**
- Free up disk space (backup needs ~installation size)
- Move to larger disk
- Clean temporary files

---

### Post-Verification Errors

**"Modified file checksum mismatch"**
```
Error: post-patch verification failed:
  file "program.exe" checksum mismatch after patching
Restoring from backup...
```

**Meaning:** Patch application produced wrong result

**Causes:**
- Corrupted patch file
- Disk error during write
- Binary diff application failed
- Memory corruption

**Solution:**
- Re-download patch file
- Check disk for errors
- Retry patching
- Report bug if persistent

---

**"Key file not found"**
```
Error: patch application failed: key file verification failed:
  key file not found: program.exe
```

**Meaning:** The key file specified in the patch cannot be found

**Causes:**
- Key file was renamed (e.g., program.exe → app.exe)
- Key file was moved to different location
- Key file was deleted

**Solution:**
- Use `--key-file` option to specify the renamed/moved key file
- Example: `patch-apply --patch 1.0.0-to-1.0.1.patch --current-dir ./myapp --key-file app.exe`
- Restore the key file to its original name/location

---

## Custom Key File Usage

### When to Use Custom Key File

The `--key-file` option is useful when:

1. **Main executable was renamed** for branding or clarity
   - `program.exe` → `MyApp.exe`
   - `server.exe` → `MyCompanyServer.exe`

2. **Executable location changed** in directory structure
   - Moved from root to `bin/` subdirectory
   - Restructured folder hierarchy

3. **Testing with renamed files** in development/staging environments

### How It Works

The key file is the primary executable that uniquely identifies your application version. When you specify a custom key file:

1. The applier uses your specified file for version verification
2. Hash is checked against expected version hash from patch
3. All other patch operations proceed normally
4. Custom key file path only affects verification, not patching operations

### Examples

**Simple rename (relative path):**
```bash
# Key file renamed from program.exe to MyApp.exe
patch-apply --patch ./patches/1.0.0-to-1.0.1.patch \
            --current-dir ./myapp \
            --key-file MyApp.exe
```

**Moved to subdirectory:**
```bash
# Key file moved to bin/ subdirectory
patch-apply --patch ./patches/1.0.0-to-1.0.1.patch \
            --current-dir ./myapp \
            --key-file bin/program.exe
```

**Absolute path:**
```bash
# Using absolute path to key file
patch-apply --patch ./patches/1.0.0-to-1.0.1.patch \
            --current-dir C:\MyApp \
            --key-file C:\MyApp\renamed_program.exe
```

**With dry-run (test before applying):**
```bash
# Test with custom key file first
patch-apply --patch ./patches/1.0.0-to-1.0.1.patch \
            --current-dir ./myapp \
            --key-file MyApp.exe \
            --dry-run
```

### GUI Support

The GUI applier also supports custom key files:

1. Select your patch file
2. Select current directory
3. Enter custom key file path in the "Custom Key:" field (optional)
4. Browse or type the path manually
5. Apply patch as normal

### Self-Contained Executable Support

Self-contained `.exe` patches also support custom key files:

1. Run the self-contained executable
2. Accept or change the target directory
3. Select option **5: Specify Custom Key File**
4. Enter the custom key file path
5. Choose **1: Dry Run** to test or **2: Apply Patch**

---

## Examples

### Example 1: Safe Production Update

Update production installation with full safety:

```bash
# Always use --verify for production!
patch-apply --patch ./patches/1.0.2-to-1.0.3.patch --current-dir C:\Production\MyApp --verify
```

**What Happens:**
1. Verifies you're running 1.0.2
2. Creates backup at `C:\Production\MyApp.backup\`
3. Applies changes
4. Verifies result is 1.0.3
5. Removes backup on success

---

### Example 2: Preview Before Applying

Preview changes before committing:

```bash
# First: Dry-run to see what would change
patch-apply --patch ./patches/1.0.0-to-1.0.3.patch --current-dir ./myapp --dry-run

# If everything looks good, apply for real:
patch-apply --patch ./patches/1.0.0-to-1.0.3.patch --current-dir ./myapp --verify
```

---

### Example 3: Testing Environment (Less Safe)

For testing environments where speed matters more than safety:

```bash
# Skip verification and backup (FASTER but RISKY!)
patch-apply --patch ./patches/1.0.0-to-1.0.3.patch --current-dir ./test-app
```

**WARNING:** Only use this for disposable test environments!

---

### Example 4: Network Drive Installation

Applying patch to network-installed application:

```bash
patch-apply --patch ./patches/1.0.1-to-1.0.2.patch --current-dir \\server\share\MyApp --verify
```

**Note:** Backup will be at `\\server\share\MyApp.backup\`

---

## Performance Expectations

### Small Patches (<10MB)
- **Pre-verification**: 2-5 seconds
- **Backup creation**: 10-30 seconds
- **Apply operations**: 3-10 seconds
- **Post-verification**: 2-5 seconds
- **Total time**: ~30-60 seconds

### Medium Patches (10-100MB)
- **Pre-verification**: 5-10 seconds
- **Backup creation**: 30-60 seconds
- **Apply operations**: 10-30 seconds
- **Post-verification**: 5-10 seconds
- **Total time**: ~1-2 minutes

### Large Patches (100MB+)
- **Pre-verification**: 10-20 seconds
- **Backup creation**: 1-3 minutes
- **Apply operations**: 30-90 seconds
- **Post-verification**: 10-20 seconds
- **Total time**: ~2-5 minutes

**Factors:**
- Installation size (backup time)
- Number of files (verification time)
- Disk speed (SSD vs HDD)
- Patch size (operation time)

---

## Best Practices

### Before Patching

1. **Close the Application**: Ensure application is not running
2. **Check Disk Space**: Ensure space for backup (~installation size)
3. **Backup Separately**: Create your own backup for critical systems
4. **Test First**: Use --dry-run to preview changes
5. **Right Patch**: Verify you have the correct patch for your version

### During Patching

1. **Use --verify**: Always use --verify flag for production
2. **Don't Interrupt**: Let the process complete
3. **Watch Output**: Monitor for errors or warnings
4. **Stable Connection**: Ensure stable disk/network access

### After Patching

1. **Test Application**: Verify application works correctly
2. **Check Version**: Confirm version was updated
3. **Remove Backup**: If successful, remove .backup folder
4. **Keep Patch**: Keep patch file for future re-installations

---

## Troubleshooting

### Patch Fails with "Version Mismatch"

**Problem:** Current version doesn't match patch requirements

**Solution:**
1. Check current version: `./myapp/program.exe --version`
2. Find correct patch for your version
3. If no patch exists, reinstall target version

---

### Backup Restoration Fails

**Problem:** Cannot restore from backup after failure

**Solution:**
1. Check disk space
2. Manually copy files from `.backup` to installation
3. Check permissions
4. Contact support if manual restoration fails

---

### Slow Performance

**Problem:** Patching takes very long

**Solution:**
1. Check disk speed (HDD vs SSD)
2. Close unnecessary applications
3. Ensure antivirus isn't scanning
4. Check if disk is fragmented (HDD)

---

### Application Won't Start After Patching

**Problem:** Application fails to run after successful patch

**Solution:**
1. Check post-verification passed (all hashes correct)
2. Re-apply patch
3. Restore from .backup if it still exists
4. Re-install clean version and try again
5. Report bug with error logs

---

## Related Documentation

- [Generator Tool Guide](generator-guide.md) - Creating patches
- [Backup Lifecycle](backup-lifecycle.md) - Understanding backups
- [Hash Verification](hash-verification.md) - How verification works
- [Troubleshooting](troubleshooting.md) - Common issues
